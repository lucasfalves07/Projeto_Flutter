// âœ… lib/pages/mensagens_aluno.dart â€” versÃ£o final sincronizada
import 'dart:math';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:poliedro_flutter/services/firestore_service.dart';

class MensagensAlunoPage extends StatefulWidget {
  const MensagensAlunoPage({super.key});

  @override
  State<MensagensAlunoPage> createState() => _MensagensAlunoPageState();
}

class _MensagensAlunoPageState extends State<MensagensAlunoPage>
    with SingleTickerProviderStateMixin {
  final _auth = FirebaseAuth.instance;
  final _fs = FirestoreService();
  final _fmt = DateFormat('dd/MM/yyyy HH:mm');

  final _buscaCtrl = TextEditingController();
  final _msgTurmaCtrl = TextEditingController();
  final _msgPrivadaCtrl = TextEditingController();

  bool _loading = true;
  String? _erro;

  String _alunoUid = '';
  String _alunoRA = '';
  List<String> _turmasIds = [];

  final Map<String, String> _turmaNome = {};
  final Map<String, Map<String, dynamic>> _professores = {};
  final Set<String> _professoresUids = {};

  String? _turmaSelecionada;
  String? _profSelecionado;

  late final TabController _tabs;

  @override
  void initState() {
    super.initState();
    _tabs = TabController(length: 2, vsync: this);
    _carregarTudo();
  }

  @override
  void dispose() {
    _tabs.dispose();
    _buscaCtrl.dispose();
    _msgTurmaCtrl.dispose();
    _msgPrivadaCtrl.dispose();
    super.dispose();
  }

  // =========================================================
  // ðŸ”¹ Carregamento inicial
  // =========================================================
  Future<void> _carregarTudo() async {
    final uid = _auth.currentUser?.uid;
    if (uid == null) {
      setState(() {
        _erro = 'UsuÃ¡rio nÃ£o autenticado.';
        _loading = false;
      });
      return;
    }

    try {
      _alunoUid = uid;
      final user = await _fs.getUserByUid(uid);
      _alunoRA = (user?['ra'] ?? '').toString();
      _turmasIds =
          (user?['turmas'] as List?)?.map((e) => e.toString()).toList() ?? [];

      // fallback busca turmaId pelo RA
      if (_turmasIds.isEmpty && _alunoRA.isNotEmpty) {
        final a = await FirebaseFirestore.instance
            .collection('alunos')
            .doc(_alunoRA)
            .get();
        if (a.exists) {
          final t = (a.data()?['turmaId'] ?? '').toString();
          if (t.isNotEmpty) _turmasIds = [t];
        }
      }

      // nomes das turmas
      for (int i = 0; i < _turmasIds.length; i += 10) {
        final fatia = _turmasIds.sublist(i, min(i + 10, _turmasIds.length));
        final qs = await FirebaseFirestore.instance
            .collection('turmas')
            .where(FieldPath.documentId, whereIn: fatia)
            .get();
        for (final d in qs.docs) {
          _turmaNome[d.id] = (d.data()['nome'] ?? d.id).toString();
        }
      }

      _turmaSelecionada = _turmasIds.isNotEmpty ? _turmasIds.first : null;

      // professores das disciplinas
      for (int i = 0; i < _turmasIds.length; i += 10) {
        final fatia = _turmasIds.sublist(i, min(i + 10, _turmasIds.length));
        final ds = await FirebaseFirestore.instance
            .collection('disciplinas')
            .where('turmaId', whereIn: fatia)
            .get();

        for (final d in ds.docs) {
          final pid = (d['professorId'] ?? '').toString();
          if (pid.isNotEmpty) _professoresUids.add(pid);
        }
      }

      // perfis dos professores
      for (final pid in _professoresUids) {
        final u = await _fs.getUserByUid(pid);
        _professores[pid] = {
          'uid': pid,
          'nome': u?['nome'] ?? 'Professor',
          'email': u?['email'] ?? '',
        };
      }

      _profSelecionado =
          _professoresUids.isNotEmpty ? _professoresUids.first : null;

      setState(() {
        _loading = false;
        _erro = null;
      });
    } catch (e) {
      setState(() {
        _erro = 'Erro ao carregar mensagens: $e';
        _loading = false;
      });
    }
  }

  // =========================================================
  // ðŸ”¹ Helpers
  // =========================================================
  String _fmtHora(dynamic tsLike) {
    DateTime? dt;
    if (tsLike is Timestamp) dt = tsLike.toDate();
    if (dt == null && tsLike is int) {
      dt = DateTime.fromMillisecondsSinceEpoch(tsLike);
    }
    return dt != null ? _fmt.format(dt) : '';
  }

  String _chatKey(String professorUid, String alunoRA) =>
      (professorUid.compareTo(alunoRA) <= 0)
          ? "${professorUid}_$alunoRA"
          : "${alunoRA}_$professorUid";

  // =========================================================
  // ðŸ”¹ Envio de mensagens
  // =========================================================
  Future<void> _enviarParaTurma() async {
    final texto = _msgTurmaCtrl.text.trim();
    if (texto.isEmpty || _turmaSelecionada == null) return;

    try {
      await FirebaseFirestore.instance
          .collection('turmas')
          .doc(_turmaSelecionada!)
          .collection('mensagens')
          .add({
        'mensagem': texto,
        'autorUid': _alunoUid,
        'autorNome': 'Aluno',
        'alunoRA': _alunoRA,
        'tipo': 'aluno->turma',
        'data': FieldValue.serverTimestamp(), // âœ… usa campo 'data'
      });
      _msgTurmaCtrl.clear();
    } catch (e) {
      _showError('Erro ao enviar mensagem: $e');
    }
  }

  Future<void> _enviarPrivado() async {
    final texto = _msgPrivadaCtrl.text.trim();
    if (texto.isEmpty || _profSelecionado == null) return;

    final profUid = _profSelecionado!;

    try {
      final db = FirebaseFirestore.instance;
      final existing = await db
          .collection('threads')
          .where('professorId', isEqualTo: profUid)
          .where('alunoRa', isEqualTo: _alunoRA)
          .limit(1)
          .get();

      DocumentReference<Map<String, dynamic>> threadRef;
      if (existing.docs.isEmpty) {
        threadRef = await db.collection('threads').add({
          'professorId': profUid,
          'alunoRa': _alunoRA,
          'participantes': [profUid, _alunoRA],
          if (_turmaSelecionada != null && _turmaSelecionada!.isNotEmpty)
            'turmaId': _turmaSelecionada,
          'aberto': true,
          'lastMessage': texto,
          'updatedAt': FieldValue.serverTimestamp(),
        });
      } else {
        threadRef = db.collection('threads').doc(existing.docs.first.id);
        await threadRef.set({
          'lastMessage': texto,
          'updatedAt': FieldValue.serverTimestamp(),
        }, SetOptions(merge: true));
      }

      await threadRef.collection('itens').add({
        'texto': texto,
        'fromUid': _alunoUid,
        'toUid': profUid,
        'createdAt': FieldValue.serverTimestamp(),
      });

      _msgPrivadaCtrl.clear();
    } catch (e) {
      _showError('Erro ao enviar mensagem privada: $e');
    }
  }
  }

  void _showError(String msg) {
    if (!mounted) return;
    ScaffoldMessenger.of(context)
        .showSnackBar(SnackBar(content: Text(msg)));
  }

  // =========================================================
  // ðŸ”¹ Interface principal
  // =========================================================
  @override
  Widget build(BuildContext context) {
    if (_loading) {
      return const Scaffold(body: Center(child: CircularProgressIndicator()));
    }
    if (_erro != null) {
      return Scaffold(
        body: Center(
          child: Text(_erro!, style: const TextStyle(color: Colors.red)),
        ),
      );
    }

    return Scaffold(
      backgroundColor: Colors.grey[50],
      appBar: AppBar(
        title: const Text('Mensagens'),
        backgroundColor: Colors.white,
        elevation: 1,
        foregroundColor: Colors.black87,
        bottom: TabBar(
          controller: _tabs,
          labelColor: Colors.black87,
          indicatorColor: Colors.blue,
          tabs: const [
            Tab(text: 'Turma'),
            Tab(text: 'Professor'),
          ],
        ),
      ),
      body: TabBarView(
        controller: _tabs,
        children: [
          _tabTurma(),
          _tabPrivado(),
        ],
      ),
    );
  }

  // =========================================================
  // ðŸ”¹ Aba de mensagens da turma
  // =========================================================
  Widget _tabTurma() {
    return Column(
      children: [
        const SizedBox(height: 8),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 12),
          child: Row(
            children: [
              Expanded(child: _dropdownTurmas()),
              const SizedBox(width: 8),
              Expanded(child: _campoBusca()),
            ],
          ),
        ),
        const SizedBox(height: 6),
        Expanded(
          child: _turmaSelecionada == null
              ? const Center(
                  child: Text('VocÃª nÃ£o estÃ¡ associado(a) a nenhuma turma.'),
                )
              : _listaMensagensTurma(_turmaSelecionada!),
        ),
        _enviarBox(
          controller: _msgTurmaCtrl,
          hint: 'Mensagem para a turma...',
          onSend: _enviarParaTurma,
        ),
      ],
    );
  }

  Widget _dropdownTurmas() {
    return DropdownButtonFormField<String>(
      value: _turmaSelecionada,
      items: _turmasIds
          .map((id) => DropdownMenuItem(
                value: id,
                child: Text(_turmaNome[id] ?? id),
              ))
          .toList(),
      onChanged: (v) => setState(() => _turmaSelecionada = v),
      decoration: _dec(),
    );
  }

  Widget _listaMensagensTurma(String turmaId) {
    final q = _buscaCtrl.text.trim().toLowerCase();

    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
          .collection('turmas')
          .doc(turmaId)
          .collection('mensagens')
          .orderBy('data', descending: true) // âœ… usa 'data'
          .snapshots(),
      builder: (context, snap) {
        if (snap.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        if (!snap.hasData || snap.data!.docs.isEmpty) {
          return const Center(child: Text('Sem mensagens nesta turma.'));
        }

        final docs = snap.data!.docs.where((d) {
          final texto =
              ((d['mensagem'] ?? d['texto'] ?? '') as String).toLowerCase();
          return q.isEmpty || texto.contains(q);
        }).toList();

        return ListView.builder(
          padding: const EdgeInsets.all(12),
          reverse: true,
          itemCount: docs.length,
          itemBuilder: (_, i) {
            final m = docs[i].data() as Map<String, dynamic>;
            final texto = m['mensagem'] ?? m['texto'] ?? '';
            final de = m['autorUid'] ?? m['de'] ?? '';
            final souEu = de == _alunoUid;
            final ts = m['data'] ?? m['createdAt'];

            return _bubble(
              texto: texto.toString(),
              hora: _fmtHora(ts),
              alinhadoDireita: souEu,
              cor: souEu ? Colors.blue.shade100 : Colors.grey.shade300,
            );
          },
        );
      },
    );
  }

  // =========================================================
  // ðŸ”¹ Aba de mensagens privadas
  // =========================================================
  Widget _tabPrivado() {
    return Column(
      children: [
        const SizedBox(height: 8),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 12),
          child: Row(
            children: [
              Expanded(child: _dropdownProfessores()),
              const SizedBox(width: 8),
              Expanded(child: _campoBusca()),
            ],
          ),
        ),
        const SizedBox(height: 6),
        Expanded(
          child: _profSelecionado == null
              ? const Center(
                  child: Text('Nenhum professor vinculado Ã s suas turmas.'),
                )
              : _listaMensagensPrivadas(_profSelecionado!),
        ),
        _enviarBox(
          controller: _msgPrivadaCtrl,
          hint: 'Mensagem para o professor...',
          onSend: _enviarPrivado,
        ),
      ],
    );
  }

  Widget _dropdownProfessores() {
    if (_professoresUids.isEmpty) return const SizedBox.shrink();
    final ordenados = _professoresUids.toList()
      ..sort((a, b) =>
          (_professores[a]?['nome'] ?? a).compareTo(_professores[b]?['nome'] ?? b));
    return DropdownButtonFormField<String>(
      value: _profSelecionado,
      items: ordenados
          .map((uid) => DropdownMenuItem(
                value: uid,
                child: Text(_professores[uid]?['nome'] ?? 'Professor'),
              ))
          .toList(),
      onChanged: (v) => setState(() => _profSelecionado = v),
      decoration: _dec(),
    );
  }

  Widget _listaMensagensPrivadas(String profUid) {
    final q = _buscaCtrl.text.trim().toLowerCase();
    return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
      stream: FirebaseFirestore.instance
          .collection('threads')
          .where('professorId', isEqualTo: profUid)
          .where('alunoRa', isEqualTo: _alunoRA)
          .limit(1)
          .snapshots(),
      builder: (context, snapThread) {
        if (snapThread.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        final threads = snapThread.data?.docs ?? [];
        if (threads.isEmpty) {
          return const Center(child: Text('Inicie uma conversa com o professor.'));
        }
        final threadId = threads.first.id;
        return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
          stream: FirebaseFirestore.instance
              .collection('threads')
              .doc(threadId)
              .collection('itens')
              .orderBy('createdAt', descending: false)
              .snapshots(),
          builder: (context, snap) {
            if (snap.connectionState == ConnectionState.waiting) {
              return const Center(child: CircularProgressIndicator());
            }
            if (!snap.hasData || snap.data!.docs.isEmpty) {
              return const Center(child: Text('Inicie uma conversa com o professor.'));
            }

            final docs = snap.data!.docs.where((d) {
              final data = d.data();
              final texto = ((data['mensagem'] ?? data['texto'] ?? '') as String).toLowerCase();
              return q.isEmpty || texto.contains(q);
            }).toList();

            return ListView.builder(
              padding: const EdgeInsets.all(12),
              itemCount: docs.length,
              itemBuilder: (_, i) {
                final m = docs[i].data();
                final texto = m['mensagem'] ?? m['texto'] ?? '';
                final de = m['fromUid'] ?? m['de'] ?? '';
                final souEu = de == _alunoUid;
                final ts = m['createdAt'];

                return _bubble(
                  texto: texto.toString(),
                  hora: _fmtHora(ts),
                  alinhadoDireita: souEu,
                  cor: souEu ? Colors.blue.shade100 : Colors.grey.shade300,
                );
              },
            );
          },
        );
      },
    );
  }
        if (!snap.hasData || snap.data!.docs.isEmpty) {
          return const Center(
              child: Text('Inicie uma conversa com o professor.'));
        }

        final docs = snap.data!.docs.where((d) {
          final texto =
              ((d['mensagem'] ?? d['texto'] ?? '') as String).toLowerCase();
          return q.isEmpty || texto.contains(q);
        }).toList();

        return ListView.builder(
          padding: const EdgeInsets.all(12),
          itemCount: docs.length,
          itemBuilder: (_, i) {
            final m = docs[i].data() as Map<String, dynamic>;
            final texto = m['mensagem'] ?? m['texto'] ?? '';
            final de = m['fromUid'] ?? m['de'] ?? '';
            final souEu = de == _alunoUid;
            final ts = m['createdAt'];

            return _bubble(
              texto: texto.toString(),
              hora: _fmtHora(ts),
              alinhadoDireita: souEu,
              cor: souEu ? Colors.blue.shade100 : Colors.grey.shade300,
            );
          },
        );
      },
    );
  }

  // =========================================================
  // ðŸ”¹ Componentes reutilizÃ¡veis
  // =========================================================
  Widget _campoBusca() {
    return TextField(
      controller: _buscaCtrl,
      onChanged: (_) => setState(() {}),
      decoration: InputDecoration(
        hintText: 'Buscar...',
        prefixIcon: const Icon(Icons.search),
        filled: true,
        fillColor: Colors.white,
        contentPadding: const EdgeInsets.symmetric(horizontal: 12),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(10),
          borderSide: const BorderSide(color: Color(0xffe8e8ee)),
        ),
      ),
    );
  }

  InputDecoration _dec() => InputDecoration(
        filled: true,
        fillColor: Colors.white,
        contentPadding:
            const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(10),
          borderSide: const BorderSide(color: Color(0xffe8e8ee)),
        ),
      );

  Widget _enviarBox({
    required TextEditingController controller,
    required String hint,
    required VoidCallback onSend,
  }) {
    return Container(
      padding: const EdgeInsets.fromLTRB(12, 8, 12, 12),
      color: Colors.white,
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: controller,
              minLines: 1,
              maxLines: 4,
              decoration: InputDecoration(
                hintText: hint,
                filled: true,
                fillColor: Colors.white,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(10),
                  borderSide: const BorderSide(color: Color(0xffe8e8ee)),
                ),
              ),
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.send, color: Colors.blue),
            onPressed: onSend,
          )
        ],
      ),
    );
  }

  Widget _bubble({
    required String texto,
    required String hora,
    required bool alinhadoDireita,
    required Color cor,
  }) {
    return Align(
      alignment: alinhadoDireita ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        margin: const EdgeInsets.symmetric(vertical: 4),
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: cor,
          borderRadius: BorderRadius.circular(12),
        ),
        child: Column(
          crossAxisAlignment:
              alinhadoDireita ? CrossAxisAlignment.end : CrossAxisAlignment.start,
          children: [
            Text(texto, style: const TextStyle(fontSize: 15)),
            const SizedBox(height: 4),
            Text(hora, style: const TextStyle(fontSize: 11, color: Colors.black54)),
          ],
        ),
      ),
    );
  }
}


